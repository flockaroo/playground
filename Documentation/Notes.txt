h1. Current Coding Roadmap
----------------------------------------------------------------------------------------------------

* Compare assembly generated for call through function pointer vs. call through interface
** Interface pointer is pointer to abstract/pure virtual base class


h1. Guidelines
----------------------------------------------------------------------------------------------------

* Runtime is design time
* Write API usage code before (or at least pseudo-usage code while) designing API
* Add stuff as it is needed (add-on instead of added in)
** Interfaces, sub-routines, ...
* IM vs. RM APIs (culling in/before logic or engine/renderer)
** Pre- or just in time loading of resources
* Make update and render data transformations mixable
** Mix where it makes sense/improves performance (e.g. particle system)
* Parallelize by data instance not transformation
* No premature parallelization
** Keep everything sequential and profile before introducing parallelism
* Order of operations
** Physics
** Application logic (incl. input processing)
** Video/audio output

h2. Coding Guidelines

* Make implicit callback-funciton invocations more explicit
** E.g. by passing potential CBs as paraeters to invoking update function
* Avoid inheritance (try to use virtual, abstract interfaces only)
** Put base-class logic into logically enclosing scope
* Code complexity management
** We are not yet giving up on RAII
** Structure using modular classes
** Add-on modules instead of adding complexity to existing modules
*** Mid-size logical units (2 k - 5 k LOC)
** Hide implementation details from module header
*** Pimplistic design principles
*** E.g. hide OpenGL details in renderer and Bullet details in physics module
* Assert often (all implicit assumptions)
* No virtual methods that are called n-times per frame
** Always use direct function/method calls for such transformations
* Use pointers only when pointer arithemtic is expected to be performed
** Except for when null references need to be represented
** Or when pointer usage feels more elegant (exception to the rule...)
* Always use struct instead of class
** That's a nice hint towards intended DoD-ness too...


h1. Module Details
----------------------------------------------------------------------------------------------------

h2. Rocket Science Module

* Consider rotational speed for dampening controller

h2. State Machine Logic Module

* Save (and load?) C code for defining state machines in a graphical way (use LLVM to parse?)
** The purpose of an instrumentable representation is improving on correctness
** First thing we need is a defintion of correctness or at least improving it
*** Could be data read in a state that is not properly initialized in prev state
*** May also be fixable by an approach similar to FutureTalk/ExtSwarmCtrl SMs
** This approach should work for both C and C++ (thus depend C language features only)

h2. State Database Module

* Out-of-elements case should be handled gracefully in release
** Return pointer to 0-element (not used ATM anyhow...)
* Write state changes to state back-buffer?
** Clone into front-buffer before next frame
** All logic of a frame uses same base state for calculations
** Double/multi-buffered state storage for interpolation?
* Scrub and replay state
** Like GC recordings
** Secondary/internal state needs to get reset on rewind (not recorded!?)
** Think about what happens to lifecycle counters on reset
** Recordings have to track creation/deletion of elements
** Keyframes have to contain lifeycle counters and oid <=> pidx tables
* Scrub and continue from state
** Like Casey's looped game logic live programming
** Might need to restore full Bullet/physics state before continue
* Object/instance handles
** Indirection on deletion (last element swapped in on deletion)
** Detect deleted objects by storing object version in handle
* Classify all state as input/primary/secondary/internal
** Input: All user input state (keyboard, ...)
** Primary: Generated by application logic
*** Mark primary states with flag?
** No need to record secondary/internal states?
* Locking strategy
** Locking per type seems to be way to go
** We have to lock-protect object creation and destruction
* Access control
** Allow limiting write access to some states? (e.g. internal states)
** More complicated schemes seem to induce too much friction
* Proper support for atomic operations
* State database contains only primary state
** Secondary/internal state is defined through program logic
*** E.g. actual mesh data loaded from model file

h2. Platform Abstraction Module

* Hot re-loading of plugins on all platforms
** Engine core features could be hot-reloadable as well
** The only things that should be static are platform abstraction and plugin handling
** There might be data/temporal dependencies inbetween plugins
* Plugin system
** Always call plugin update function with fixed dt
** Must be easy to turn sub-module of plugin into plugin (common interface)
* DLL interface could be function returning pointer to interface class

h2. Renderer Module

* Implement special effects as plugins
** Renderer provides base infrastructure/graphics API abstraction only
** Allow low-level plugins with full OpenGL access?
*** Better to fully integrate into renderer?
* Frame buffer abstraction
** Render to texture
** Culling always depends on camera bound to frame buffer
** Output window is always special/first frame buffer
* Camera system
** Manual vs. automatic modes
*** Manual: Logic explicitly sets position and target
*** Automatic: Orbit mesh, relative to mesh
* Driving renderer by primary state allows for easy renderer unit tests
** Simply restore state, render frame and diff pixel output with ground truth
* Prevent OpenGL driver serialization/pipeline stall
** Do not use any 'glGet*'-functions (incl. 'glGetError')
** Use "ARB_debug_output" extension (should tell us when we are making a mistake)
* Do not use Vertex Array Object
** "Slower than glVertexAttribPointer on all implementations" according to Valve
* Vertex specification best practices
** Interleaving vertex attributes in vertex buffer objects not necessarily a good idea


h1. Design
----------------------------------------------------------------------------------------------------

h2. Abstraction Layers

* Platform abstraction (static code)
** High resolution timers
** User input
** Graphics API
** Memory management
** Profiling
** Plugin handling
** Filesystem (incl. queued/overlapped IO)
** Networking

* Engine abstraction (dynamic code?)
** Assets (textures/videos, models, shaders, audio, ...)
*** Runtime reloadable
*** File IO hidden behind abstraction (may not be loaded from files...)
*** Assets should be referred to using hash values
** Video output/rendering (meshes, materials, cameras, buffers, effects?, culling?)
** Physics
** Sound output
** Networking
** Profiling

* Application logic (dynamic code)
** Runtime hot reloadable
** Uses engine abstraction to define application
** State machine mechanisms


h1. Research Backlog
----------------------------------------------------------------------------------------------------

* Chandler Carruth "Efficiency with Algorithms, Performance with Data Structures" 
** https://www.youtube.com/watch?v=fHNmRkzxHWs
* Glenn Fiedler's networked physics article series for networking/state-distribution
* BitSquid engine articles for general engine design
** http://bitsquid.blogspot.se/2014/09/building-data-oriented-entity-system.html
