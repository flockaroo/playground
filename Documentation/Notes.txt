h1. Coding Roadmap
----------------------------------------------------------------------------------------------------

h2. Prototype Jan 2015

* Simply structured, single threaded, SDL-based physics prototyping application
* Avoid inheritance (try to use virtual, abstract interfaces only)
** Put base-class logic into logically enclosing scope
* Structure around data held in 'StateDb' data container (StateTracker 2.0)
* 'Module' interface definition for decoupling potential future plugins
* 'Physics' module implementing simple rigid body physics using Bullet
* 'Assets' module for managing assets (models, textures, shaders)
* 'Renderer' module providing simple OpenGL rendering (no VBOs and textures)
* 'RocketScience' module providing application logic
* Compare assembly generated for call through function pointer vs. call through pointer to interface 
** Interface pointer is pointer to abstract/pure virtual base class

h1. General Notes
----------------------------------------------------------------------------------------------------

* Runtime is design time
* Scrub and replay state
** Like GC recordings
* Scrub and continue from state
** Like Casey's looped game logic live programming

* Write API usage code before (or at least pseudo-usage code while) designing API
* Save (and load?) C code for defining state machines in a graphical way (use LLVM to parse?)
** The purpose of an instrumentable representation is improving on correctness
** First thing we need is a defintion of correctness or at least improving it
*** Could be data read in a state that is not properly initialized in prev state
*** May also be fixable by an approach similar to FutureTalk/ExtSwarmCtrl SMs
** This approach should work for both C and C++ (thus depend C language features only)
* Add stuff as it is needed (add-on instead of added in)
** Interfaces, sub-routines, ...
* IM vs. RM APIs (culling in/before logic or engine/renderer)
** Pre- or just in time loading of resources
* Make update and render data transformations mixable
** Mix where it makes sense/improves performance (e.g. particle system)
* Parallelize by data instance not transformation
* No premature parallelization
* Order of operations
** Physics
** Application logic (incl. input processing)
** Video/audio output

h2. Coding Guidelines

* Code complexity management
** We are not yet giving up on RAII
** Structure using modular classes
*** Mid-size logical units (2 k - 5 k LOC)
** Hide implementation details from module header
*** Pimplistic design principles
*** E.g. hide OpenGL details in renderer and Bullet details in physics module
* Assert often (all implicit assumptions)
* No virtual methods that are called n-times per frame
** Always use direct function/method calls for such transformations
* Use pointers only when pointer arithemtic is expected to be performed
** Or when pointer usage feels more elegant (exception to the rule...)
* Always use struct instead of class
** That's a nice hint towards intended DoD-ness too...

h2. State Database

* Object/instance handles
** Indirection on deletion (last element swapped in on deletion)
** Detect deleted objects by storing object version in handle
* Classify all state as input/primary/secondary/internal
** Input: All user input state (keyboard, ...)
** Primary: Generated by application logic
** Mark primary states with flag?
** No need to record secondary/internal states?
* Locking strategy
** Locking per type seems to be way to go
** We have to lock-protect object creation and destruction
* Access control
** Allow limiting write access to some states? (e.g. internal states)
** More complicated schemes seem to induce too much friction
* Proper support for atomic operations
* State database contains only primary state
** Secondary state is defined through program logic
*** E.g. actual mesh data loaded from model file

h2. Platform Abstraction

* Hot re-loading of plugins on all platforms
** Engine core features could be hot-reloadable as well
** The only things that should be static are platform abstraction and plugin handling
** There might be data/temporal dependencies inbetween plugins
* Plugin system
** Always call plugin update function with fixed dt
** Must be easy to turn sub-module of plugin into plugin (common interface)
* DLL interface could be function returning pointer to interface class

h2. Renderer

* Frame buffer abstraction
** Render to texture
** Culling always depends on camera bound to frame buffer
** Output window is always special/first frame buffer
* Camera system
** Manual vs. automatic modes
*** Manual: Logic explicitly sets position and target
*** Automatic: Orbit mesh, relative to mesh
* Driving renderer by primary state allows for easy renderer unit tests
** Simply restore state, render frame and diff pixel output with ground truth
* Prevent OpenGL driver serialization/pipeline stall
** Do not use any 'glGet*'-functions (incl. 'glGetError')
** Use ARB_debug_output extension (should tell us when we are making a mistake)
* Do not use Vertex Array Object
** "Slower than glVertexAttribPointer on all implementations" according to Valve
* Vertex specification best practices
** Interleaving vertex attributes in vertex buffer objects not necessarily a good idea

h1. Design
----------------------------------------------------------------------------------------------------

h2. Abstraction Layers

* Platform abstraction (static code)
** High resolution timers
** User input
** Graphics API
** Memory management
** Profiling
** Plugin handling
** Filesystem (incl. queued/overlapped IO)
** Networking

* Engine abstraction (dynamic code?)
** Assets (textures/videos, models, shaders, audio, ...)
*** Runtime reloadable
*** File IO hidden behind abstraction (may not be loaded from files...)
*** Assets should be referred to using hash values
** Video output/rendering (meshes, materials, cameras, buffers, effects?, culling?)
** Physics
** Sound output
** Networking

* Application logic (dynamic code)
** Runtime hot reloadable
** Uses engine abstraction to define application
** State machine mechanisms

h1. Research Backlog
----------------------------------------------------------------------------------------------------

* Chandler Carruth "Efficiency with Algorithms, Performance with Data Structures" 
** https://www.youtube.com/watch?v=fHNmRkzxHWs
