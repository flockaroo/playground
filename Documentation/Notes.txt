h1. Coding Roadmap
----------------------------------------------------------------------------------------------------

h2. Prototype Jan 2015

* Hard-coded vertex and fragment shaders
* Hard-coded cube rendering draw calls (position and color vertex attributes)
* Cube instancing driven by state database

* Simply structured, single threaded, SDL-based physics prototyping application
* Avoid inheritance (try to use virtual, abstract interfaces only)
** Put base-class logic into logically enclosing scope
* Structure around data held in 'StateDb' data container (StateTracker 2.0)
* 'Module' interface definition for decoupling potential future plugins
* 'Physics' module implementing simple rigid body physics using Bullet
* 'Assets' module for managing assets (models, textures, shaders)
* 'Renderer' module providing simple OpenGL rendering (no VBOs and textures)
* 'RocketScience' module providing application logic
* Compare assembly generated for call through function pointer vs. call through pointer to interface 
** Interface pointer is pointer to abstract/pure virtual base class

h1. General Notes
----------------------------------------------------------------------------------------------------

* Runtime is design time
* Write API usage code before (or at least pseudo-usage code while) designing API
* Save (and load?) C code for defining state machines in a graphical way (use LLVM to parse?)
** The purpose of an instrumentable representation is improving on correctness
** First thing we need is a defintion of correctness or at least improving it
*** Could be data read in a state that is not properly initialized in prev state
*** May also be fixable by an approach similar to FutureTalk/ExtSwarmCtrl SMs
** This approach should work for both C and C++ (thus depend C language features only)
* Hot re-loading of plugins on all platforms
** Engine core features could be hot-reloadable as well
** The only things that should be static are platform abstraction and plugin handling
** There might be data/temporal dependencies inbetween plugins
* Add stuff as it is needed (add-on instead of added in)
** Interfaces, sub-routines, ...
* IM vs. RM APIs (culling in/before logic or engine/renderer)
** Pre- or just in time loading of resources
* Make update and render transformations mixable (mix where it makes sense)
* Parallelize by data instance not transformation
* Assert implicit assumptions
* No premature parallelization
* Order of operations
** Physics
** Application logic (incl. input processing)
** Video/audio output
* StateDb
** Proper support for atomic operations
** Keep object indices through indirection on deletion (fill hole on delete)
* Plugin system
** Always call plugin update function with fixed dt
** Must be easy to turn sub-module of plugin into plugin (common interface)
* DLL interface could be function returning pointer to interface class
* No virtual methods that need to be called n-times per frame
** Always use direct function/method calls for such transformations
* Driving renderer by state database allows for easy renderer unit tests
** Simply restore state, render frame and check pixel output
* State database contains only primary state
** Secondary state is defined through program logic
*** E.g. actual mesh data loaded from model file
* Prevent OpenGL driver serialization/pipeline stall
** Do not use any 'glGet*'-functions (incl. 'glGetError')
** Use ARB_debug_output extension
* Do not use Vertex Array Object
** "Slower than glVertexAttribPointer on all implementations" according to Valve
* Vertex Specification Best Practices
** Interleaving vertex attributes in vertex buffer objects not necessarily a good idea
* Use pointers only when pointer arithemtic is expected to be performed
* Always use struct instead of class - that's a nice hint towards DoD too...

h1. Design
----------------------------------------------------------------------------------------------------

h2. Abstraction Layers

* Platform abstraction (static code)
** High resolution timers
** User input
** Graphics API
** Memory management
** Profiling
** Plugin handling
** Filesystem (incl. queued/overlapped IO)
** Networking

* Engine abstraction (static code or dynamic code?)
** Assets (textures/videos, models, shaders, audio, ...)
*** Runtime reloadable
*** File IO hidden behind abstraction (may not be loaded from files...)
*** Assets should be referred to using hash values
** Video output/rendering (meshes, materials, cameras, buffers, effects?, culling?)
** Physics
** Sound output
** Networking

* Logic plugin (dynamic code)
** Runtime hot reloadable
** Uses engine abstraction to define application
** State machine mechanisms

h1. Research Backlog
----------------------------------------------------------------------------------------------------

* Chandler Carruth "Efficiency with Algorithms, Performance with Data Structures" 
** https://www.youtube.com/watch?v=fHNmRkzxHWs
